package cjdev

import std.argopt.{ArgumentParseException, parseArguments, ArgumentSpec, ArgumentMode, ParsedArguments}
import std.env.{atExit, exit, getVariable}
import std.fs.{exists, Path}
import stdx.log.{setGlobalLogger, Logger, LogLevel}
import stdx.serialization.serialization.DataModel
import cangjie_toml.cangjie_toml.FromToml
import registry.{Registry, Builder, extra.entry.AddLazy, extra.entry.AddTransient}
import cjdev.config.{CjDevConfig, GeneralConfig, ProjectsConfig}
import cjdev.features.Dc
import cjdev.logging.createGlobalLogger

private const CJDEV_CONFIG_PATH_TAG = "cjdev.config.path"
private const CJDEV_CONFIG_AUTOGENERATED_TAG = "cjdev.config.autoGenerated"
private const CJDEV_LOGGER_GLOBAL_TAG = "cjdev.logger.global"
private const CJDEV_LOG_LEVEL_TAG = "cjdev.log.level"
private const CJDEV_LOG_DIR_TAG = "cjdev.log.dir"

/**
 * CjDev immutable service locator.
 * MUST be used only in the file its declared.
 */
private let REGISTRY: Registry = Registry
    .builder()
    // features
    .addLazy<CjDev> {reg => CjDev(reg.get<Dc>(), reg.get<Logger>(CJDEV_LOGGER_GLOBAL_TAG))}
    .addLazy<Dc> {reg => Dc(reg.get<GeneralConfig>(), reg.get<Logger>(CJDEV_LOGGER_GLOBAL_TAG))}
    // config
    .addLazy<Path>(CJDEV_CONFIG_PATH_TAG) {
        _ => Path("cjdev.toml")
    }
    .addLazy<CjDevConfig> {
        reg =>
            let logger = reg.get<Logger>(CJDEV_LOGGER_GLOBAL_TAG)
            let configPath = reg.get<Path>(CJDEV_CONFIG_PATH_TAG)
            if (!exists(configPath)) {
                logger.warn("config file does not exist, using default configuration",
                    ("configPath", configPath.toString()))
                return CjDevConfig.default()
            }

            try {
                DataModel.fromTomlFile(configPath) |> CjDevConfig.deserialize
            } catch (e: Exception) {
                logger.error("unable to parse the config file, using default configuration",
                    [("cause", e.message), ("configPath", configPath.toString())])
                return CjDevConfig.default()
            }
    }
    .addTransient<Bool>(CJDEV_CONFIG_AUTOGENERATED_TAG) {reg => reg.get<CjDevConfig>().autoGenerated}
    .addTransient<GeneralConfig> {
        reg => reg.get<CjDevConfig>().general
    }
    .addTransient<ProjectsConfig> {
        reg => reg.get<CjDevConfig>().projects
    }
    // logging
    .addLazy<LogLevel>() {
        _ => getVariable("CJDEV_LOG_LEVEL").getOrDefault {=> "info"} |> LogLevel.from
    }
    .addLazy<Path>(CJDEV_LOG_DIR_TAG) {_ => Path(getVariable("CJDEV_LOG_DIR").getOrDefault {=> "logs"})}
    .addLazy<Logger>(CJDEV_LOGGER_GLOBAL_TAG) {
        reg => createGlobalLogger(reg.get<LogLevel>(), reg.get<Path>(CJDEV_LOG_DIR_TAG))
    }
    .build()

/**
 * CjDev entrypoint.
 * Sets environment, logging and `atExit` callback
 */
public func cjDev(args: Array<String>): Unit {
    let logger = REGISTRY.get<Logger>(CJDEV_LOGGER_GLOBAL_TAG)
    setGlobalLogger(logger)
    atExit {=> logger.close()}
    REGISTRY.get<CjDev>().execute(args)
}

private class CjDev {
    public CjDev(private let dc_: Dc, private let logger_: Logger) {}

    public func execute(args: Array<String>): Unit {
        try {
            let parsed = parseArguments(args, CJDEV_ARGS_SPEC)
            if (parsed.options.contains("version") || parsed.options.contains("V")) {
                printVersion()
                return
            }

            let cmd = parsed.nonOptions.get(0)
            match (cmd) {
                case Some("dc") => dc_.execute(parsed)
                // TODO: Exception
                case Some(cmd) => throw Exception("no such command: `${cmd}`")
                case None => printHelp()
            }
        } catch (e: Exception) {
            logger_.error(e.message)
            printUsage()
            exit(1)
        }
    }

    private static let CJDEV_ARGS_SPEC = [Full("version", r'V', NoValue), Full("verbose", r'v', NoValue),
        Full("help", r'h', NoValue)];
    private static const CJDEV_VERSION = "0.1.0"
    private static const CJDEV_USAGE = "Usage: cjdev [OPTIONS] <COMMAND>"
    private static let CJDEV_HELP = """
Cangjie's developer utility tool

${CJDEV_USAGE}

Options:
  -V, --version   Print version info and exit
  -v, --verbose   Use verbose output
  -h, --help      Print help

Commands:
  status    Show the cjdev environment status
  init, i   Init cjdev environment
  build     Build Cangjie's projects
  test      Test Cangjie's projects
  git       Git utils for Cangjie's repositories management
  dc        Execute a command in the container."""

    private func printHelp(): Unit {
        println(CJDEV_HELP)
    }

    private func printUsage(): Unit {
        println(CJDEV_USAGE)
    }

    private func printVersion(): Unit {
        println("cjdev ${CJDEV_VERSION}")
    }
}

extend LogLevel {
    /**
     * @throws UnsupportedLogLevelException
     */
    static func from(value: String): LogLevel {
        match (value.toAsciiUpper()) {
            case "OFF" => OFF
            case "FATAL" => FATAL
            case "ERROR" => ERROR
            case "WARN" => WARN
            case "INFO" => INFO
            case "DEBUG" => DEBUG
            case "TRACE" => TRACE
            case "ALL" => ALL
            case _ => throw UnsupportedLogLevelException(value)
        }
    }
}

protected class UnsupportedLogLevelException <: Exception {
    UnsupportedLogLevelException(name: String) {
        super("LogLevel: ${name} is not supported")
    }
}
