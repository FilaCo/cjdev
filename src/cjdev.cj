package cjdev

import std.argopt.{ArgumentParseException, parseArguments, ArgumentSpec, ArgumentMode, ParsedArguments}
import std.env.{atExit, exit, getVariable}
import std.fs.{exists, Path}
import stdx.log.{setGlobalLogger, Logger, LogLevel}
import stdx.serialization.serialization.DataModel
import cangjie_toml.cangjie_toml.FromToml
import registry.{Registry, Builder, extra.entry.AddLazy, extra.entry.AddTransient}
import cjdev.config.{CjDevConfig, GeneralConfig, ProjectsConfig}
import cjdev.features.Dc
import cjdev.logging.createGlobalLogger
import cjdev.utils.{CommandLauncher, BashCommandLauncher, DockerCommandLauncher}

private const CJDEV_CONFIG_PATH_TAG = "cjdev.config.path"
private const CJDEV_CONFIG_AUTOGENERATED_TAG = "cjdev.config.autoGenerated"
private const CJDEV_LOGGER_GLOBAL_TAG = "cjdev.logger.global"
private const CJDEV_LOG_DIR_TAG = "cjdev.log.dir"
private const CJDEV_COMMAND_LAUNCHER_BASE = "cjdev.commandLauncher.base"
private const CJDEV_COMMAND_LAUNCHER_CONTAINER = "cjdev.commandLauncher.container"

/**
 * CjDev immutable service locator.
 * MUST be used only in the file its declared.
 */
private let REGISTRY: Registry = Registry
    .builder()
    // features
    .addLazy<CjDev> {reg => CjDev(reg.get<Dc>(), reg.get<Logger>(CJDEV_LOGGER_GLOBAL_TAG))}
    .addLazy<Dc> {reg => Dc(reg.get<CommandLauncher>(), reg.get<Logger>(CJDEV_LOGGER_GLOBAL_TAG))}
    // config
    .addLazy<Path>(CJDEV_CONFIG_PATH_TAG) {
        _ => Path("cjdev.toml")
    }
    .addLazy<CjDevConfig> {
        reg =>
            let logger = reg.get<Logger>(CJDEV_LOGGER_GLOBAL_TAG)
            let configPath = reg.get<Path>(CJDEV_CONFIG_PATH_TAG)
            if (!exists(configPath)) {
                logger.warn("config file does not exist, using default configuration",
                    ("configPath", configPath.toString()))
                return CjDevConfig.default()
            }

            try {
                DataModel.fromTomlFile(configPath) |> CjDevConfig.deserialize
            } catch (e: Exception) {
                logger.error("unable to parse the config file, using default configuration",
                    [("cause", e.message), ("configPath", configPath.toString())])
                return CjDevConfig.default()
            }
    }
    .addTransient<Bool>(CJDEV_CONFIG_AUTOGENERATED_TAG) {reg => reg.get<CjDevConfig>().autoGenerated}
    .addTransient<GeneralConfig> {
        reg => reg.get<CjDevConfig>().general
    }
    .addTransient<ProjectsConfig> {
        reg => reg.get<CjDevConfig>().projects
    }
    // logging
    .addLazy<Path>(CJDEV_LOG_DIR_TAG) {_ => Path(getVariable("CJDEV_LOG_DIR").getOrDefault {=> "logs"})}
    .addLazy<Logger>(CJDEV_LOGGER_GLOBAL_TAG) {
        reg => createGlobalLogger(reg.get<Path>(CJDEV_LOG_DIR_TAG))
    }
    // utils
    .addLazy<CommandLauncher> {
        reg =>
            let useDocker = reg.get<GeneralConfig>().useDocker
            if (useDocker) {
                CjDevContainerCommandLauncher()
            } else {
                BaseCommandLauncher()
            }
    }
    .addLazy<CommandLauncher>(CJDEV_COMMAND_LAUNCHER_BASE) {_ => BaseCommandLauncher()}
    .build()

/**
 * CjDev entrypoint.
 * Sets environment, logging and `atExit` callback
 */
public func cjDev(args: Array<String>): Unit {
    let logger = REGISTRY.get<Logger>(CJDEV_LOGGER_GLOBAL_TAG)
    setGlobalLogger(logger)
    atExit {=> logger.close()}
    REGISTRY.get<CjDev>().execute(args)
}

private class CjDev {
    public CjDev(private let dc_: Dc, private let logger_: Logger) {}

    public func execute(args: Array<String>): Unit {
        try {
            let parsed = parseArguments(args, CJDEV_ARGS_SPEC)
            let options = parsed.options
            var nonOptions = parsed.nonOptions
            if (options.contains("version") || options.contains("V")) {
                printVersion()
                return
            }

            if (nonOptions.isEmpty()) {
                printHelp()
                return
            }

            let cmd = nonOptions[0]
            nonOptions = nonOptions[1..]
            match (cmd) {
                case "dc" => dc_.execute(options, nonOptions)
                // TODO: Exception
                case cmd => throw Exception("no such command: `${cmd}`")
            }
        } catch (e: Exception) {
            logger_.error(e.message)
            printUsage()
            exit(1)
        }
    }

    private static let CJDEV_ARGS_SPEC = [Full("version", r'V', NoValue), Full("verbose", r'v', NoValue),
        Full("help", r'h', NoValue)];
    private static const CJDEV_VERSION = "0.1.0"
    private static const CJDEV_USAGE = "Usage: cjdev [OPTIONS] <COMMAND>"
    private static let CJDEV_HELP = """
Cangjie's developer utility tool

${CJDEV_USAGE}

Options:
  -V, --version   Print version info and exit
  -v, --verbose   Use verbose output
  -h, --help      Print help

Commands:
  status    Show the cjdev environment status
  init, i   Init cjdev environment
  build     Build Cangjie's projects
  test      Test Cangjie's projects
  git       Git utils for Cangjie's repositories management
  dc        Execute a command in the container."""

    private func printHelp(): Unit {
        println(CJDEV_HELP)
    }

    private func printUsage(): Unit {
        println(CJDEV_USAGE)
    }

    private func printVersion(): Unit {
        println("cjdev ${CJDEV_VERSION}")
    }
}
